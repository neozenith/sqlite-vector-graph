/**
 * muninn WASM Demo — App logic
 *
 * Loads the muninn WASM module, discovers the 3300.db schema,
 * and wires up search → embedding → HNSW → graph traversal → visualization.
 *
 * 3D coordinates come from pre-calculated UMAP tables (*_umap) in the database,
 * generated by wasm/scripts/encode_umap_embeddings.py.
 */

// ── Global State ──────────────────────────────────────────────────────

let db = null; // SQLite WASM database pointer
let sqlite = null; // SQLite WASM API wrappers
let Module = null; // Emscripten module
let sentenceEmbedder = null; // Transformers.js pipeline
let deckInstance = null; // Deck.GL instance
let cyInstance = null; // Cytoscape instance
let dbSchema = null; // Discovered schema info
let searchDebounce = null;

// ── Status Management ─────────────────────────────────────────────────

function setStatus(id, status) {
  const el = document.getElementById(`status-${id}`);
  if (el) el.dataset.status = status;
}

// ── Library Loading ───────────────────────────────────────────────────

async function waitFor(check, name, maxAttempts = 100) {
  let attempts = 0;
  while (!check() && attempts < maxAttempts) {
    await new Promise((r) => setTimeout(r, 200));
    attempts++;
  }
  if (!check()) {
    throw new Error(`${name} failed to load after ${maxAttempts * 200}ms`);
  }
}

// ── SQLite WASM Initialization ────────────────────────────────────────

async function initWasm() {
  setStatus("wasm", "loading");
  try {
    Module = await createMuninnSQLite();

    // Wrap core SQLite C API functions
    sqlite = {
      open: Module.cwrap("sqlite3_open", "number", ["string", "number"]),
      close: Module.cwrap("sqlite3_close", "number", ["number"]),
      exec: Module.cwrap("sqlite3_exec", "number", [
        "number",
        "string",
        "number",
        "number",
        "number",
      ]),
      errmsg: Module.cwrap("sqlite3_errmsg", "string", ["number"]),
      prepare_v2: Module.cwrap("sqlite3_prepare_v2", "number", [
        "number",
        "string",
        "number",
        "number",
        "number",
      ]),
      step: Module.cwrap("sqlite3_step", "number", ["number"]),
      finalize: Module.cwrap("sqlite3_finalize", "number", ["number"]),
      column_text: Module.cwrap("sqlite3_column_text", "string", [
        "number",
        "number",
      ]),
      column_int: Module.cwrap("sqlite3_column_int", "number", [
        "number",
        "number",
      ]),
      column_double: Module.cwrap("sqlite3_column_double", "number", [
        "number",
        "number",
      ]),
      column_blob: Module.cwrap("sqlite3_column_blob", "number", [
        "number",
        "number",
      ]),
      column_bytes: Module.cwrap("sqlite3_column_bytes", "number", [
        "number",
        "number",
      ]),
      column_count: Module.cwrap("sqlite3_column_count", "number", ["number"]),
      column_name: Module.cwrap("sqlite3_column_name", "string", [
        "number",
        "number",
      ]),
      bind_blob: Module.cwrap("sqlite3_bind_blob", "number", [
        "number",
        "number",
        "number",
        "number",
        "number",
      ]),
      reset: Module.cwrap("sqlite3_reset", "number", ["number"]),
      free: Module.cwrap("sqlite3_free", "void", ["number"]),
    };

    // Register muninn as an auto-extension (must be called before sqlite3_open)
    Module.ccall("sqlite3_wasm_extra_init", "number", ["string"], [null]);

    // Fetch and load the database file into Emscripten FS
    const response = await fetch("assets/3300.db");
    const arrayBuffer = await response.arrayBuffer();
    const data = new Uint8Array(arrayBuffer);
    Module.FS.writeFile("/3300.db", data);

    // Open the database
    const dbPtrPtr = Module._malloc(4);
    const rc = sqlite.open("/3300.db", dbPtrPtr);
    if (rc !== 0) {
      throw new Error(`sqlite3_open failed: rc=${rc}`);
    }
    db = Module.getValue(dbPtrPtr, "i32");
    Module._free(dbPtrPtr);

    setStatus("wasm", "ready");
    console.log("WASM SQLite initialized with 3300.db");
    return true;
  } catch (err) {
    setStatus("wasm", "error");
    console.error("WASM init failed:", err);
    throw err;
  }
}

// ── SQL Query Helpers ─────────────────────────────────────────────────

const SQLITE_ROW = 100;

function query(sql) {
  const stmtPtrPtr = Module._malloc(4);
  const rc = sqlite.prepare_v2(db, sql, -1, stmtPtrPtr, 0);
  if (rc !== 0) {
    Module._free(stmtPtrPtr);
    throw new Error(`prepare failed (${rc}): ${sqlite.errmsg(db)}`);
  }
  const stmt = Module.getValue(stmtPtrPtr, "i32");
  Module._free(stmtPtrPtr);

  const cols = sqlite.column_count(stmt);
  const colNames = [];
  for (let i = 0; i < cols; i++) {
    colNames.push(sqlite.column_name(stmt, i));
  }

  const rows = [];
  while (sqlite.step(stmt) === SQLITE_ROW) {
    const row = {};
    for (let i = 0; i < cols; i++) {
      row[colNames[i]] = sqlite.column_text(stmt, i);
    }
    rows.push(row);
  }

  sqlite.finalize(stmt);
  return { columns: colNames, rows };
}

// ── Schema Discovery ──────────────────────────────────────────────────

function discoverSchema() {
  const tables = query(
    "SELECT name, type FROM sqlite_master WHERE type IN ('table','view') ORDER BY name",
  );
  const hnswConfigs = [];

  // Find HNSW virtual tables by looking for _config shadow tables
  for (const t of tables.rows) {
    if (t.name.endsWith("_config")) {
      const base = t.name.replace(/_config$/, "");
      try {
        const cfg = query(`SELECT key, value FROM "${t.name}"`);
        const config = {};
        for (const r of cfg.rows) config[r.key] = r.value;
        config._base = base;
        hnswConfigs.push(config);
      } catch (_) {
        // Not an HNSW config table
      }
    }
  }

  // Count key tables
  const counts = {};
  for (const name of ["chunks", "entities", "relations", "edges", "nodes"]) {
    try {
      const r = query(`SELECT COUNT(*) as n FROM "${name}"`);
      counts[name] = parseInt(r.rows[0].n);
    } catch (_) {
      counts[name] = 0;
    }
  }

  // Discover UMAP tables
  const umapTables = tables.rows
    .filter((t) => t.name.endsWith("_umap"))
    .map((t) => t.name);

  dbSchema = { tables: tables.rows, hnswConfigs, counts, umapTables };

  const statusEl = document.getElementById("db-status");
  statusEl.textContent =
    `Database: ${counts.chunks} chunks, ${counts.entities} entities, ` +
    `${counts.relations} relations, ${hnswConfigs.length} HNSW indexes, ` +
    `${umapTables.length} UMAP tables`;

  console.log("Schema discovered:", dbSchema);
  return dbSchema;
}

// ── Transformers.js Initialization ────────────────────────────────────

async function initTransformers() {
  setStatus("transformers", "loading");
  try {
    await waitFor(() => window.transformers, "Transformers.js");

    sentenceEmbedder = await window.transformers.pipeline(
      "feature-extraction",
      "Xenova/all-MiniLM-L6-v2",
      { pooling: "mean", normalize: true },
    );

    setStatus("transformers", "ready");
    console.log("Sentence transformer model loaded (384-dim)");
    return sentenceEmbedder;
  } catch (err) {
    setStatus("transformers", "error");
    console.error("Transformers.js init failed:", err);
    throw err;
  }
}

async function generateEmbedding(text) {
  const output = await sentenceEmbedder(text, {
    pooling: "mean",
    normalize: true,
  });
  return Array.from(output.data);
}

// ── Deck.GL Initialization ────────────────────────────────────────────

function initDeckGL() {
  setStatus("deckgl", "loading");
  try {
    const container = document.getElementById("deckgl-container");
    if (!container || !window.deck) {
      throw new Error("Deck.GL container or library not found");
    }

    const canvas = document.createElement("canvas");
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    container.appendChild(canvas);

    const lightingEffect = new deck.LightingEffect({
      ambientLight: new deck.AmbientLight({
        color: [255, 255, 255],
        intensity: 0.3,
      }),
      directionalLight: new deck.DirectionalLight({
        color: [255, 255, 255],
        intensity: 0.8,
        direction: [-1, -1, -2],
      }),
    });

    deckInstance = new deck.Deck({
      canvas: canvas,
      width: container.clientWidth,
      height: container.clientHeight || 400,
      views: [new deck.OrbitView({ orbitAxis: "Y", fov: 50 })],
      initialViewState: { target: [0, 0, 0], zoom: 1 },
      controller: true,
      effects: [lightingEffect],
      layers: [],
      getTooltip: ({ object }) =>
        object && {
          html: `<div style="max-width:250px">${object.text || ""}</div>`,
          style: {
            backgroundColor: "rgba(0,0,0,0.85)",
            color: "white",
            padding: "8px 12px",
            borderRadius: "6px",
            fontSize: "12px",
          },
        },
    });

    window.deckInstance = deckInstance;
    setStatus("deckgl", "ready");
    console.log("Deck.GL initialized");
    return deckInstance;
  } catch (err) {
    setStatus("deckgl", "error");
    console.error("Deck.GL init failed:", err);
    // Non-fatal: WebGL may not work in headless
  }
}

function updateDeckGL(points) {
  if (!deckInstance) return;

  const sphere = new luma.SphereGeometry({ radius: 1, nlat: 10, nlong: 20 });

  deckInstance.setProps({
    layers: [
      new deck.SimpleMeshLayer({
        id: "embedding-points",
        data: points,
        mesh: sphere,
        getPosition: (d) => d.position,
        getColor: (d) => d.color,
        getTransformMatrix: (d) => [
          d.radius,
          0,
          0,
          0,
          0,
          d.radius,
          0,
          0,
          0,
          0,
          d.radius,
          0,
          0,
          0,
          0,
          1,
        ],
        pickable: true,
        autoHighlight: true,
        updateTriggers: {
          getPosition: points,
          getColor: points,
          getTransformMatrix: points,
        },
      }),
    ],
  });

  const countEl = document.getElementById("deckgl-count");
  countEl.textContent = `${points.length} points`;

  const placeholder = document.getElementById("deckgl-placeholder");
  if (placeholder) placeholder.style.display = "none";
}

// ── Cytoscape Initialization ──────────────────────────────────────────

function initCytoscape() {
  setStatus("cytoscape", "loading");
  try {
    if (!window.cytoscape) {
      throw new Error("Cytoscape library not found");
    }

    cyInstance = cytoscape({
      container: document.getElementById("cy"),
      elements: [],
      style: [
        {
          selector: "node",
          style: {
            width: "data(size)",
            height: "data(size)",
            label: "data(label)",
            "text-valign": "center",
            "text-halign": "center",
            "font-size": "10px",
            color: "#e5e7eb",
            "text-outline-width": 2,
            "text-outline-color": "#1f2937",
            "background-color": "data(color)",
          },
        },
        {
          selector: "edge",
          style: {
            width: 2,
            "line-color": "#4b5563",
            "target-arrow-color": "#4b5563",
            "target-arrow-shape": "triangle",
            "curve-style": "bezier",
            label: "data(label)",
            "font-size": "8px",
            color: "#6b7280",
            "text-rotation": "autorotate",
          },
        },
        {
          selector: ".highlighted",
          style: {
            "background-color": "#818cf8",
            "line-color": "#818cf8",
            "target-arrow-color": "#818cf8",
          },
        },
        {
          selector: ".query-node",
          style: {
            "background-color": "#f87171",
            "border-width": 3,
            "border-color": "#fca5a5",
          },
        },
      ],
      layout: { name: "grid", rows: 1 },
      zoomingEnabled: true,
      panningEnabled: true,
    });

    setStatus("cytoscape", "ready");
    console.log("Cytoscape initialized");
    return cyInstance;
  } catch (err) {
    setStatus("cytoscape", "error");
    console.error("Cytoscape init failed:", err);
  }
}

function updateCytoscape(nodes, edges) {
  if (!cyInstance) return;

  cyInstance.elements().remove();

  const elements = [];

  for (const n of nodes) {
    elements.push({
      group: "nodes",
      data: {
        id: n.name,
        label: n.name,
        size: 20 + Math.min(n.mentions || 0, 10) * 4,
        color: entityColor(n.type),
      },
    });
  }

  for (const e of edges) {
    // Only add edge if both nodes exist
    if (
      elements.some((el) => el.data.id === e.src) &&
      elements.some((el) => el.data.id === e.dst)
    ) {
      elements.push({
        group: "edges",
        data: {
          id: `${e.src}-${e.rel}-${e.dst}`,
          source: e.src,
          target: e.dst,
          label: e.rel || "",
        },
      });
    }
  }

  cyInstance.add(elements);
  cyInstance.layout({ name: "cose", animate: false, padding: 30 }).run();

  const countEl = document.getElementById("cytoscape-count");
  countEl.textContent = `${nodes.length} nodes`;
}

function entityColor(type) {
  const colors = {
    PERSON: "#f59e0b",
    ORG: "#3b82f6",
    GPE: "#10b981",
    CONCEPT: "#8b5cf6",
    WORK: "#ec4899",
    EVENT: "#ef4444",
    LOC: "#14b8a6",
  };
  return colors[type] || "#6b7280";
}

// ── Search Flow ───────────────────────────────────────────────────────

async function performSearch(queryText) {
  if (!queryText.trim()) return;

  const spinner = document.getElementById("search-spinner");
  spinner.classList.remove("hidden");

  try {
    // 1. Generate query embedding
    const queryEmbedding = await generateEmbedding(queryText);
    console.log(`Generated ${queryEmbedding.length}-dim query embedding`);

    // 2. HNSW vector search via muninn
    // Pack embedding as float32 blob
    const floatArray = new Float32Array(queryEmbedding);
    const blobPtr = Module._malloc(floatArray.byteLength);
    Module.HEAPF32.set(floatArray, blobPtr >> 2);

    // Use chunks_vec (384-dim, matches all-MiniLM-L6-v2)
    // HNSW virtual table uses MATCH operator for KNN search
    const searchSql = `
      SELECT rowid, distance
      FROM chunks_vec
      WHERE vector MATCH ?
      AND k = 20
    `;
    const stmtPtrPtr = Module._malloc(4);
    let rc = sqlite.prepare_v2(db, searchSql, -1, stmtPtrPtr, 0);
    if (rc !== 0) {
      Module._free(stmtPtrPtr);
      Module._free(blobPtr);
      throw new Error(`search prepare: ${sqlite.errmsg(db)}`);
    }
    const stmt = Module.getValue(stmtPtrPtr, "i32");
    Module._free(stmtPtrPtr);

    // Bind the blob (SQLITE_TRANSIENT = -1: SQLite copies the data)
    rc = sqlite.bind_blob(stmt, 1, blobPtr, floatArray.byteLength, -1);
    if (rc !== 0) {
      sqlite.finalize(stmt);
      Module._free(blobPtr);
      throw new Error(`bind_blob: ${sqlite.errmsg(db)}`);
    }

    const searchResults = [];
    while (sqlite.step(stmt) === SQLITE_ROW) {
      searchResults.push({
        rowid: parseInt(sqlite.column_text(stmt, 0)),
        distance: parseFloat(sqlite.column_text(stmt, 1)),
      });
    }
    sqlite.finalize(stmt);
    Module._free(blobPtr);

    console.log(`HNSW search returned ${searchResults.length} results`);

    if (searchResults.length === 0) {
      showResults([]);
      return;
    }

    // 3. Fetch chunk texts for results
    const rowids = searchResults.map((r) => r.rowid).join(",");
    const chunks = query(
      `SELECT chunk_id, text FROM chunks WHERE chunk_id IN (${rowids})`,
    );
    const chunkMap = {};
    for (const c of chunks.rows) chunkMap[c.chunk_id] = c.text;

    // 4. Fetch pre-calculated 3D UMAP coordinates
    const umapResults = query(
      `SELECT id, x3d, y3d, z3d FROM chunks_vec_umap WHERE id IN (${rowids})`,
    );
    const umapMap = {};
    for (const u of umapResults.rows) {
      umapMap[u.id] = [parseFloat(u.x3d), parseFloat(u.y3d), parseFloat(u.z3d)];
    }

    // 5. Build result objects
    const results = searchResults.map((sr) => ({
      id: sr.rowid,
      text: chunkMap[sr.rowid] || `Chunk #${sr.rowid}`,
      similarity: 1 - sr.distance, // cosine distance → similarity
      distance: sr.distance,
    }));

    // 6. Graph traversal: find entities mentioned in matching chunks
    const matchedChunkIds = searchResults.map((r) => r.rowid).join(",");
    const entityResults = query(`
      SELECT DISTINCT e.name, e.entity_type
      FROM entities e
      WHERE e.chunk_id IN (${matchedChunkIds})
      LIMIT 30
    `);

    const entityNames = entityResults.rows.map((r) => r.name);
    let graphNodes = entityResults.rows.map((r) => ({
      name: r.name,
      type: r.entity_type,
      mentions: 1,
    }));

    let graphEdges = [];
    if (entityNames.length > 0) {
      const quotedNames = entityNames
        .map((n) => `'${n.replace(/'/g, "''")}'`)
        .join(",");
      const edgeResults = query(`
        SELECT src, dst, rel_type, weight
        FROM relations
        WHERE src IN (${quotedNames}) OR dst IN (${quotedNames})
        LIMIT 50
      `);
      graphEdges = edgeResults.rows.map((r) => ({
        src: r.src,
        dst: r.dst,
        rel: r.rel_type,
        weight: parseFloat(r.weight),
      }));

      // Add any nodes referenced by edges but not yet in graphNodes
      const nodeSet = new Set(graphNodes.map((n) => n.name));
      for (const e of graphEdges) {
        for (const name of [e.src, e.dst]) {
          if (!nodeSet.has(name)) {
            nodeSet.add(name);
            graphNodes.push({ name, type: null, mentions: 0 });
          }
        }
      }
    }

    // 7. Update visualizations
    showResults(results);
    updateCytoscape(graphNodes, graphEdges);

    // 8. Build 3D points from pre-calculated UMAP coordinates
    const points = results.map((r, i) => {
      const coords = umapMap[r.id];
      return {
        position: coords || [
          // Fallback: circular layout if UMAP coords missing
          Math.cos((i / results.length) * Math.PI * 2) * 30,
          (r.similarity - 0.5) * 60,
          Math.sin((i / results.length) * Math.PI * 2) * 30,
        ],
        color: [100, 150, 250],
        radius: 3 + r.similarity * 8,
        text: `${r.text.slice(0, 80)}...\nSimilarity: ${(r.similarity * 100).toFixed(1)}%`,
        similarity: r.similarity,
      };
    });
    updateDeckGL(points);
  } catch (err) {
    console.error("Search failed:", err);
  } finally {
    spinner.classList.add("hidden");
  }
}

// ── Results Panel ─────────────────────────────────────────────────────

function showResults(results) {
  const panel = document.getElementById("results-panel");
  const list = document.getElementById("results-list");

  if (results.length === 0) {
    panel.classList.add("hidden");
    return;
  }

  panel.classList.remove("hidden");
  list.innerHTML = "";

  for (const r of results) {
    const pct = (r.similarity * 100).toFixed(1);
    const card = document.createElement("div");
    card.className = "result-card";
    card.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <span class="text-xs text-indigo-400 font-medium">Chunk #${r.id}</span>
        <span class="text-xs text-gray-400">${pct}%</span>
      </div>
      <p class="text-sm text-gray-300 line-clamp-3">${escapeHtml(r.text.slice(0, 200))}</p>
      <div class="mt-2 bg-gray-800 rounded-full overflow-hidden">
        <div class="similarity-bar" style="width: ${pct}%"></div>
      </div>
    `;
    list.appendChild(card);
  }
}

function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}

// ── Initialization ────────────────────────────────────────────────────

async function initialize() {
  console.log("Initializing muninn WASM demo...");

  try {
    // Phase 1: WASM + SQLite (critical path)
    await initWasm();
    discoverSchema();

    // Phase 2: Visualization (non-blocking for WebGL issues)
    initDeckGL();
    initCytoscape();

    // Phase 3: ML model (slow — first load downloads ~30MB model)
    await initTransformers();

    // Enable search
    const input = document.getElementById("search-input");
    input.disabled = false;
    const hint = document.getElementById("search-hint");
    hint.textContent =
      "Type a query to search the Wealth of Nations knowledge graph.";

    input.addEventListener("input", (e) => {
      clearTimeout(searchDebounce);
      searchDebounce = setTimeout(() => {
        performSearch(e.target.value);
      }, 300);
    });

    console.log("muninn WASM demo ready");
  } catch (err) {
    console.error("Initialization failed:", err);
    const hint = document.getElementById("search-hint");
    hint.textContent = `Initialization failed: ${err.message}`;
    hint.classList.add("text-red-400");
  }
}

document.addEventListener("DOMContentLoaded", initialize);
