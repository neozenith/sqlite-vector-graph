/**
 * muninn WASM Demo — App logic
 *
 * Loads the muninn WASM module, discovers the 3300.db schema,
 * and wires up search → embedding → HNSW → graph traversal → visualization.
 *
 * 3D coordinates come from pre-calculated UMAP tables (*_umap) in the database,
 * generated by wasm/scripts/encode_umap_embeddings.py or kg_extract.py.
 *
 * Three-panel search:
 *   Left:   FTS5 full-text results (instant, no embedding needed)
 *   Center: HNSW embedding space (3D UMAP point cloud, rank-colored)
 *   Right:  Knowledge graph (CTE: VSS → anchor → BFS → filter)
 */

// ── Global State ──────────────────────────────────────────────────────

let db = null; // SQLite WASM database pointer
let sqlite = null; // SQLite WASM API wrappers
let Module = null; // Emscripten module
let sentenceEmbedder = null; // Transformers.js pipeline
let deckInstance = null; // Deck.GL instance
let cyInstance = null; // Cytoscape instance
let dbSchema = null; // Discovered schema info
let searchDebounce = null;

// ── Status Management ─────────────────────────────────────────────────

function setStatus(id, status) {
  const el = document.getElementById(`status-${id}`);
  if (el) el.dataset.status = status;
}

// ── Library Loading ───────────────────────────────────────────────────

async function waitFor(check, name, maxAttempts = 100) {
  let attempts = 0;
  while (!check() && attempts < maxAttempts) {
    await new Promise((r) => setTimeout(r, 200));
    attempts++;
  }
  if (!check()) {
    throw new Error(`${name} failed to load after ${maxAttempts * 200}ms`);
  }
}

// ── SQLite WASM Initialization ────────────────────────────────────────

async function initWasm() {
  setStatus("wasm", "loading");
  try {
    Module = await createMuninnSQLite();

    // Wrap core SQLite C API functions
    sqlite = {
      open: Module.cwrap("sqlite3_open", "number", ["string", "number"]),
      close: Module.cwrap("sqlite3_close", "number", ["number"]),
      exec: Module.cwrap("sqlite3_exec", "number", [
        "number",
        "string",
        "number",
        "number",
        "number",
      ]),
      errmsg: Module.cwrap("sqlite3_errmsg", "string", ["number"]),
      prepare_v2: Module.cwrap("sqlite3_prepare_v2", "number", [
        "number",
        "string",
        "number",
        "number",
        "number",
      ]),
      step: Module.cwrap("sqlite3_step", "number", ["number"]),
      finalize: Module.cwrap("sqlite3_finalize", "number", ["number"]),
      column_text: Module.cwrap("sqlite3_column_text", "string", [
        "number",
        "number",
      ]),
      column_int: Module.cwrap("sqlite3_column_int", "number", [
        "number",
        "number",
      ]),
      column_double: Module.cwrap("sqlite3_column_double", "number", [
        "number",
        "number",
      ]),
      column_blob: Module.cwrap("sqlite3_column_blob", "number", [
        "number",
        "number",
      ]),
      column_bytes: Module.cwrap("sqlite3_column_bytes", "number", [
        "number",
        "number",
      ]),
      column_count: Module.cwrap("sqlite3_column_count", "number", ["number"]),
      column_name: Module.cwrap("sqlite3_column_name", "string", [
        "number",
        "number",
      ]),
      bind_blob: Module.cwrap("sqlite3_bind_blob", "number", [
        "number",
        "number",
        "number",
        "number",
        "number",
      ]),
      bind_text: Module.cwrap("sqlite3_bind_text", "number", [
        "number",
        "number",
        "string",
        "number",
        "number",
      ]),
      bind_int: Module.cwrap("sqlite3_bind_int", "number", [
        "number",
        "number",
        "number",
      ]),
      reset: Module.cwrap("sqlite3_reset", "number", ["number"]),
      free: Module.cwrap("sqlite3_free", "void", ["number"]),
    };

    // Register muninn as an auto-extension (must be called before sqlite3_open)
    Module.ccall("sqlite3_wasm_extra_init", "number", ["string"], [null]);

    // Fetch and load the database file into Emscripten FS
    const response = await fetch("assets/3300.db");
    const arrayBuffer = await response.arrayBuffer();
    const data = new Uint8Array(arrayBuffer);
    Module.FS.writeFile("/3300.db", data);

    // Open the database
    const dbPtrPtr = Module._malloc(4);
    const rc = sqlite.open("/3300.db", dbPtrPtr);
    if (rc !== 0) {
      throw new Error(`sqlite3_open failed: rc=${rc}`);
    }
    db = Module.getValue(dbPtrPtr, "i32");
    Module._free(dbPtrPtr);

    setStatus("wasm", "ready");
    console.log("WASM SQLite initialized with 3300.db");
    return true;
  } catch (err) {
    setStatus("wasm", "error");
    console.error("WASM init failed:", err);
    throw err;
  }
}

// ── SQL Query Helpers ─────────────────────────────────────────────────

const SQLITE_ROW = 100;

function query(sql) {
  const stmtPtrPtr = Module._malloc(4);
  const rc = sqlite.prepare_v2(db, sql, -1, stmtPtrPtr, 0);
  if (rc !== 0) {
    Module._free(stmtPtrPtr);
    throw new Error(`prepare failed (${rc}): ${sqlite.errmsg(db)}`);
  }
  const stmt = Module.getValue(stmtPtrPtr, "i32");
  Module._free(stmtPtrPtr);

  const cols = sqlite.column_count(stmt);
  const colNames = [];
  for (let i = 0; i < cols; i++) {
    colNames.push(sqlite.column_name(stmt, i));
  }

  const rows = [];
  while (sqlite.step(stmt) === SQLITE_ROW) {
    const row = {};
    for (let i = 0; i < cols; i++) {
      row[colNames[i]] = sqlite.column_text(stmt, i);
    }
    rows.push(row);
  }

  sqlite.finalize(stmt);
  return { columns: colNames, rows };
}

/**
 * Execute a parameterized query with bindings.
 * bindings: array of { index, type, value } where type is 'text', 'int', or 'blob'.
 * For blob: value = { ptr, size } (caller manages memory).
 */
function queryBound(sql, bindings) {
  const stmtPtrPtr = Module._malloc(4);
  const rc = sqlite.prepare_v2(db, sql, -1, stmtPtrPtr, 0);
  if (rc !== 0) {
    Module._free(stmtPtrPtr);
    throw new Error(`prepare failed (${rc}): ${sqlite.errmsg(db)}`);
  }
  const stmt = Module.getValue(stmtPtrPtr, "i32");
  Module._free(stmtPtrPtr);

  for (const b of bindings) {
    let brc;
    if (b.type === "text") {
      brc = sqlite.bind_text(stmt, b.index, b.value, -1, 0);
    } else if (b.type === "int") {
      brc = sqlite.bind_int(stmt, b.index, b.value);
    } else if (b.type === "blob") {
      // SQLITE_TRANSIENT = -1
      brc = sqlite.bind_blob(stmt, b.index, b.value.ptr, b.value.size, -1);
    }
    if (brc !== 0) {
      sqlite.finalize(stmt);
      throw new Error(`bind (idx=${b.index}): ${sqlite.errmsg(db)}`);
    }
  }

  const cols = sqlite.column_count(stmt);
  const colNames = [];
  for (let i = 0; i < cols; i++) {
    colNames.push(sqlite.column_name(stmt, i));
  }

  const rows = [];
  while (sqlite.step(stmt) === SQLITE_ROW) {
    const row = {};
    for (let i = 0; i < cols; i++) {
      row[colNames[i]] = sqlite.column_text(stmt, i);
    }
    rows.push(row);
  }

  sqlite.finalize(stmt);
  return { columns: colNames, rows };
}

// ── Schema Discovery ──────────────────────────────────────────────────

function discoverSchema() {
  const tables = query(
    "SELECT name, type FROM sqlite_master WHERE type IN ('table','view') ORDER BY name",
  );
  const hnswConfigs = [];

  // Find HNSW virtual tables by looking for _config shadow tables
  for (const t of tables.rows) {
    if (t.name.endsWith("_config")) {
      const base = t.name.replace(/_config$/, "");
      try {
        const cfg = query(`SELECT key, value FROM "${t.name}"`);
        const config = {};
        for (const r of cfg.rows) config[r.key] = r.value;
        config._base = base;
        hnswConfigs.push(config);
      } catch (_) {
        // Not an HNSW config table
      }
    }
  }

  // Count key tables
  const counts = {};
  for (const name of ["chunks", "entities", "relations", "edges", "nodes"]) {
    try {
      const r = query(`SELECT COUNT(*) as n FROM "${name}"`);
      counts[name] = parseInt(r.rows[0].n);
    } catch (_) {
      counts[name] = 0;
    }
  }

  // Discover UMAP tables
  const umapTables = tables.rows
    .filter((t) => t.name.endsWith("_umap"))
    .map((t) => t.name);

  dbSchema = { tables: tables.rows, hnswConfigs, counts, umapTables };

  const statusEl = document.getElementById("db-status");
  statusEl.textContent =
    `Database: ${counts.chunks} chunks, ${counts.entities} entities, ` +
    `${counts.relations} relations, ${hnswConfigs.length} HNSW indexes, ` +
    `${umapTables.length} UMAP tables`;

  console.log("Schema discovered:", dbSchema);
  return dbSchema;
}

// ── Transformers.js Initialization ────────────────────────────────────

async function initTransformers() {
  setStatus("transformers", "loading");
  try {
    await waitFor(() => window.transformers, "Transformers.js");

    // Xenova fork provides ONNX files in the layout Transformers.js expects.
    // Force full-precision fp32 weights (not quantized int8) for embedding parity
    // with Python sentence-transformers. Quantized gives ~49%, fp32 gives ~87%.
    sentenceEmbedder = await window.transformers.pipeline(
      "feature-extraction",
      "Xenova/all-MiniLM-L6-v2",
      { pooling: "mean", normalize: true, quantized: false },
    );

    setStatus("transformers", "ready");
    console.log("Sentence transformer model loaded (384-dim, fp32)");
    return sentenceEmbedder;
  } catch (err) {
    setStatus("transformers", "error");
    console.error("Transformers.js init failed:", err);
    throw err;
  }
}

async function generateEmbedding(text) {
  const output = await sentenceEmbedder(text, {
    pooling: "mean",
    normalize: true,
  });
  return Array.from(output.data);
}

// ── Rank-Based Colors ─────────────────────────────────────────────────

/**
 * Rank-based color gradient: red (top) → orange → purple (lowest).
 * rank 0 = best match = red, rank total-1 = worst = purple.
 */
function rankColor(rank, total) {
  if (rank === 0) return [255, 60, 60];
  if (total <= 1) return [255, 60, 60];
  const t = (rank - 1) / (total - 1);
  // Orange [255,140,50] → Purple [140,60,220]
  return [
    Math.round(255 + (140 - 255) * t),
    Math.round(140 + (60 - 140) * t),
    Math.round(50 + (220 - 50) * t),
  ];
}

// ── Deck.GL Initialization ────────────────────────────────────────────

function initDeckGL() {
  setStatus("deckgl", "loading");
  try {
    const container = document.getElementById("deckgl-container");
    if (!container || !window.deck) {
      throw new Error("Deck.GL container or library not found");
    }

    const canvas = document.createElement("canvas");
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    container.appendChild(canvas);

    const lightingEffect = new deck.LightingEffect({
      ambientLight: new deck.AmbientLight({
        color: [255, 255, 255],
        intensity: 0.3,
      }),
      directionalLight: new deck.DirectionalLight({
        color: [255, 255, 255],
        intensity: 0.8,
        direction: [-1, -1, -2],
      }),
    });

    deckInstance = new deck.Deck({
      canvas: canvas,
      width: container.clientWidth,
      height: container.clientHeight || 400,
      views: [new deck.OrbitView({ orbitAxis: "Y", fov: 50 })],
      initialViewState: { target: [0, 0, 0], zoom: 1 },
      controller: true,
      effects: [lightingEffect],
      layers: [],
      getTooltip: ({ object }) => {
        if (!object) return null;
        const pct = (object.similarity * 100).toFixed(1);
        const text =
          object.chunkText.length > 80
            ? object.chunkText.substring(0, 80) + "..."
            : object.chunkText;
        return {
          html: `<div style="max-width:300px"><div style="font-weight:600; margin-bottom:4px">Chunk #${object.chunkId} &middot; ${pct}%</div><div style="font-size:11px; line-height:1.4">${text || "No text"}</div></div>`,
          style: {
            backgroundColor: "rgba(0,0,0,0.85)",
            color: "white",
            padding: "8px 12px",
            borderRadius: "6px",
            fontSize: "12px",
          },
        };
      },
    });

    window.deckInstance = deckInstance;
    setStatus("deckgl", "ready");
    console.log("Deck.GL initialized");
    return deckInstance;
  } catch (err) {
    setStatus("deckgl", "error");
    console.error("Deck.GL init failed:", err);
    // Non-fatal: WebGL may not work in headless
  }
}

function updateDeckGL(points) {
  if (!deckInstance) return;

  const sphere = new luma.SphereGeometry({ radius: 1, nlat: 10, nlong: 20 });

  // Compute centroid of all points
  let cx = 0,
    cy = 0,
    cz = 0;
  for (const p of points) {
    cx += p.position[0];
    cy += p.position[1];
    cz += p.position[2];
  }
  const n = points.length || 1;
  cx /= n;
  cy /= n;
  cz /= n;

  // Compute bounding radius from centroid (including max sphere radius)
  let maxR = 0;
  for (const p of points) {
    const dx = p.position[0] - cx;
    const dy = p.position[1] - cy;
    const dz = p.position[2] - cz;
    const r = Math.sqrt(dx * dx + dy * dy + dz * dz) + p.radius;
    if (r > maxR) maxR = r;
  }

  // Calculate zoom to fit all points in the viewport with padding
  const container = document.getElementById("deckgl-container");
  const viewSize =
    Math.min(container.clientWidth, container.clientHeight) || 400;
  const padding = 2.0; // breathing room around the point cloud
  const effectiveRadius = maxR * padding || 1;
  const zoom = Math.log2(viewSize / (2 * effectiveRadius));

  deckInstance.setProps({
    initialViewState: {
      target: [cx, cy, cz],
      zoom: zoom,
      rotationX: 30,
      rotationOrbit: -30,
    },
    layers: [
      new deck.SimpleMeshLayer({
        id: "embedding-points",
        data: points,
        mesh: sphere,
        getPosition: (d) => d.position,
        getColor: (d) => d.color,
        getTransformMatrix: (d) => [
          d.radius,
          0,
          0,
          0,
          0,
          d.radius,
          0,
          0,
          0,
          0,
          d.radius,
          0,
          0,
          0,
          0,
          1,
        ],
        pickable: true,
        autoHighlight: true,
        updateTriggers: {
          getPosition: points,
          getColor: points,
          getTransformMatrix: points,
        },
      }),
    ],
  });

  const countEl = document.getElementById("deckgl-count");
  countEl.textContent = `${points.length} points`;

  const placeholder = document.getElementById("deckgl-placeholder");
  if (placeholder) placeholder.style.display = "none";
}

// ── Cytoscape Initialization ──────────────────────────────────────────

function initCytoscape() {
  setStatus("cytoscape", "loading");
  try {
    if (!window.cytoscape) {
      throw new Error("Cytoscape library not found");
    }

    cyInstance = cytoscape({
      container: document.getElementById("cy"),
      elements: [],
      style: [
        {
          selector: "node",
          style: {
            width: "data(size)",
            height: "data(size)",
            label: "data(label)",
            "text-valign": "center",
            "text-halign": "center",
            "font-size": "10px",
            color: "#e5e7eb",
            "text-outline-width": 2,
            "text-outline-color": "#1f2937",
            "background-color": "data(color)",
          },
        },
        {
          selector: "edge",
          style: {
            width: 2,
            "line-color": "#4b5563",
            "target-arrow-color": "#4b5563",
            "target-arrow-shape": "triangle",
            "curve-style": "bezier",
            label: "data(label)",
            "font-size": "8px",
            color: "#6b7280",
            "text-rotation": "autorotate",
          },
        },
        {
          selector: ".highlighted",
          style: {
            "background-color": "#818cf8",
            "line-color": "#818cf8",
            "target-arrow-color": "#818cf8",
          },
        },
        {
          selector: ".query-node",
          style: {
            "background-color": "#f87171",
            "border-width": 3,
            "border-color": "#fca5a5",
          },
        },
      ],
      layout: { name: "grid", rows: 1 },
      zoomingEnabled: true,
      panningEnabled: true,
    });

    window.cyInstance = cyInstance;
    setStatus("cytoscape", "ready");
    console.log("Cytoscape initialized");
    return cyInstance;
  } catch (err) {
    setStatus("cytoscape", "error");
    console.error("Cytoscape init failed:", err);
  }
}

function updateCytoscape(nodes, edges) {
  if (!cyInstance) return;

  cyInstance.elements().remove();

  const elements = [];

  for (const n of nodes) {
    elements.push({
      group: "nodes",
      data: {
        id: n.name,
        label: n.name,
        size: n.isAnchor ? 40 : 20 + Math.min(n.similarity || 0, 1) * 20,
        color: n.isAnchor ? "#f87171" : nodeColor(n.similarity || 0),
      },
      classes: n.isAnchor ? "query-node" : "",
    });
  }

  for (const e of edges) {
    // Only add edge if both nodes exist
    if (
      elements.some((el) => el.data.id === e.src) &&
      elements.some((el) => el.data.id === e.dst)
    ) {
      elements.push({
        group: "edges",
        data: {
          id: `${e.src}-${e.rel}-${e.dst}`,
          source: e.src,
          target: e.dst,
          label: e.rel || "",
        },
      });
    }
  }

  cyInstance.add(elements);
  cyInstance.layout({ name: "cose", animate: false, padding: 30 }).run();
  cyInstance.fit(undefined, 20);

  const countEl = document.getElementById("cytoscape-count");
  countEl.textContent = `${nodes.length} nodes`;

  // Show/hide graph layout controls
  const controls = document.getElementById("graph-controls");
  if (controls) {
    controls.classList.toggle("hidden", nodes.length === 0);
  }
}

function nodeColor(similarity) {
  // High similarity = warm (orange), low = cool (indigo)
  if (similarity > 0.5) return "#f59e0b";
  if (similarity > 0.2) return "#8b5cf6";
  return "#6b7280";
}

// ── Graph Layout Controls ──────────────────────────────────────────

function rerunLayout() {
  if (!cyInstance) return;
  const repulsion = parseInt(document.getElementById("repulsion").value);
  const edgeLength = parseInt(document.getElementById("edge-length").value);
  const gravity = parseFloat(document.getElementById("gravity").value);
  cyInstance
    .layout({
      name: "cose",
      animate: false,
      padding: 30,
      nodeRepulsion: () => repulsion,
      idealEdgeLength: () => edgeLength,
      gravity: gravity,
    })
    .run();
  cyInstance.fit(undefined, 20);
}

function initGraphControls() {
  const sliders = [
    { id: "repulsion", valId: "repulsion-val", fmt: (v) => v },
    { id: "edge-length", valId: "edge-length-val", fmt: (v) => v },
    {
      id: "gravity",
      valId: "gravity-val",
      fmt: (v) => parseFloat(v).toFixed(2),
    },
  ];

  for (const s of sliders) {
    const el = document.getElementById(s.id);
    if (el) {
      el.addEventListener("input", () => {
        document.getElementById(s.valId).textContent = s.fmt(el.value);
      });
    }
  }

  const btn = document.getElementById("run-layout-btn");
  if (btn) btn.addEventListener("click", rerunLayout);
}

// ── FTS5 Search ───────────────────────────────────────────────────────

function performFtsSearch(queryText) {
  try {
    // FTS5 MATCH with simple prefix matching
    const ftsQuery = queryText
      .trim()
      .split(/\s+/)
      .map((w) => `"${w.replace(/"/g, "")}"`)
      .join(" ");

    const results = queryBound(
      `SELECT chunk_id, text FROM chunks WHERE chunk_id IN (
        SELECT rowid FROM chunks_fts WHERE chunks_fts MATCH ?1 LIMIT 20
      )`,
      [{ index: 1, type: "text", value: ftsQuery }],
    );

    return results.rows.map((r) => ({
      id: parseInt(r.chunk_id),
      text: r.text,
    }));
  } catch (err) {
    console.warn("FTS search failed:", err.message);
    return [];
  }
}

// ── CTE Graph Query ───────────────────────────────────────────────────

/**
 * Single CTE query: VSS broad search → anchor entity → BFS 1-hop → filter.
 * Returns { nodes: [...], edges: [...] }.
 */
function performGraphSearch(blobPtr, blobSize, broadK, bfsDepth) {
  // Query 1: Get scored nodes via CTE (VSS → anchor → BFS → score)
  // Must be a separate query because SQLite CTEs referencing virtual tables
  // (HNSW MATCH, graph_bfs) are not reliably materialized — re-evaluation
  // in UNION ALL or IN subqueries returns empty results.
  const NODE_SQL = `
    WITH
    vss_matches AS (
        SELECT rowid AS vec_rowid, distance AS cosine_distance
        FROM entities_vec
        WHERE vector MATCH ?1 AND k = ?2
    ),
    vss_entities AS (
        SELECT m.name, v.cosine_distance, (1.0 - v.cosine_distance) AS similarity
        FROM vss_matches v
        JOIN entity_vec_map m ON m.rowid = v.vec_rowid
    ),
    anchor AS (
        SELECT name FROM vss_entities ORDER BY cosine_distance ASC LIMIT 1
    ),
    bfs_neighbors AS (
        SELECT node, depth
        FROM graph_bfs
        WHERE edge_table = 'relations' AND src_col = 'src' AND dst_col = 'dst'
          AND start_node = (SELECT name FROM anchor)
          AND max_depth = ?3 AND direction = 'both'
    ),
    scored AS (
        SELECT b.node, b.depth,
               COALESCE(v.cosine_distance, 1.0) AS cosine_distance,
               COALESCE(v.similarity, 0.0) AS similarity
        FROM bfs_neighbors b
        LEFT JOIN vss_entities v ON v.name = b.node
    )
    SELECT node AS name, depth, similarity FROM scored
  `;

  try {
    const nodeResult = queryBound(NODE_SQL, [
      { index: 1, type: "blob", value: { ptr: blobPtr, size: blobSize } },
      { index: 2, type: "text", value: String(broadK) },
      { index: 3, type: "text", value: String(bfsDepth) },
    ]);

    const nodes = nodeResult.rows.map((row) => ({
      name: row.name,
      depth: parseInt(row.depth),
      similarity: parseFloat(row.similarity),
      isAnchor: parseInt(row.depth) === 0,
    }));

    // Query 2: Get edges between the discovered nodes (plain SQL, no virtual tables)
    let edges = [];
    if (nodes.length > 1) {
      const names = nodes
        .map((n) => `'${n.name.replace(/'/g, "''")}'`)
        .join(",");
      const edgeResult = query(
        `SELECT src, rel_type, dst FROM relations
         WHERE src IN (${names}) AND dst IN (${names})`,
      );
      edges = edgeResult.rows.map((row) => ({
        src: row.src,
        dst: row.dst,
        rel: row.rel_type,
      }));
    }

    console.log(`Graph search: ${nodes.length} nodes, ${edges.length} edges`);
    return { nodes, edges };
  } catch (err) {
    console.warn("Graph search failed:", err.message);
    return { nodes: [], edges: [] };
  }
}

// ── Search Flow ───────────────────────────────────────────────────────

async function performSearch(queryText) {
  if (!queryText.trim()) return;

  const spinner = document.getElementById("search-spinner");
  spinner.classList.remove("hidden");

  try {
    // Path 1: FTS5 search (instant — no embedding needed)
    const ftsResults = performFtsSearch(queryText);
    showFtsResults(ftsResults);

    // Path 2: HNSW search + CTE graph (requires embedding)
    const queryEmbedding = await generateEmbedding(queryText);
    console.log(
      `Generated ${queryEmbedding.length}-dim query embedding, ` +
        `sample: [${queryEmbedding.slice(0, 3).map((v) => v.toFixed(4))}]`,
    );

    // Pack embedding as float32 blob
    const floatArray = new Float32Array(queryEmbedding);
    const blobPtr = Module._malloc(floatArray.byteLength);
    Module.HEAPF32.set(floatArray, blobPtr >> 2);

    try {
      // HNSW vector search on chunks_vec
      const searchSql = `
        SELECT rowid, distance
        FROM chunks_vec
        WHERE vector MATCH ?
        AND k = 20
      `;
      const stmtPtrPtr = Module._malloc(4);
      let rc = sqlite.prepare_v2(db, searchSql, -1, stmtPtrPtr, 0);
      if (rc !== 0) {
        Module._free(stmtPtrPtr);
        throw new Error(`search prepare: ${sqlite.errmsg(db)}`);
      }
      const stmt = Module.getValue(stmtPtrPtr, "i32");
      Module._free(stmtPtrPtr);

      rc = sqlite.bind_blob(stmt, 1, blobPtr, floatArray.byteLength, -1);
      if (rc !== 0) {
        sqlite.finalize(stmt);
        throw new Error(`bind_blob: ${sqlite.errmsg(db)}`);
      }

      const searchResults = [];
      while (sqlite.step(stmt) === SQLITE_ROW) {
        searchResults.push({
          rowid: parseInt(sqlite.column_text(stmt, 0)),
          distance: parseFloat(sqlite.column_text(stmt, 1)),
        });
      }
      sqlite.finalize(stmt);

      console.log(
        `HNSW search returned ${searchResults.length} results` +
          (searchResults.length > 0
            ? `, top similarity: ${(1 - searchResults[0].distance).toFixed(3)}`
            : ""),
      );

      // Fetch chunk texts and UMAP coords for results
      if (searchResults.length > 0) {
        const rowids = searchResults.map((r) => r.rowid).join(",");
        const chunks = query(
          `SELECT chunk_id, text FROM chunks WHERE chunk_id IN (${rowids})`,
        );
        const chunkMap = {};
        for (const c of chunks.rows) chunkMap[c.chunk_id] = c.text;

        const umapResults = query(
          `SELECT id, x3d, y3d, z3d FROM chunks_vec_umap WHERE id IN (${rowids})`,
        );
        const umapMap = {};
        for (const u of umapResults.rows) {
          umapMap[u.id] = [
            parseFloat(u.x3d),
            parseFloat(u.y3d),
            parseFloat(u.z3d),
          ];
        }

        // Show results list below the embedding canvas
        showEmbeddingResults(searchResults, chunkMap);

        // Build 3D points with rank-based colors
        const total = searchResults.length;
        const points = searchResults.map((sr, rank) => {
          const coords = umapMap[sr.rowid];
          const similarity = 1 - sr.distance;
          return {
            position: coords || [
              Math.cos((rank / total) * Math.PI * 2) * 30,
              (similarity - 0.5) * 60,
              Math.sin((rank / total) * Math.PI * 2) * 30,
            ],
            color: rankColor(rank, total),
            radius: 3 + similarity * 8,
            chunkId: sr.rowid,
            chunkText: chunkMap[sr.rowid] || "",
            similarity: similarity,
          };
        });
        updateDeckGL(points);
      }

      // CTE Graph search on entities_vec
      const graph = performGraphSearch(
        blobPtr,
        floatArray.byteLength,
        50, // broad k for VSS
        1, // BFS depth
      );
      updateCytoscape(graph.nodes, graph.edges);
    } finally {
      Module._free(blobPtr);
    }
  } catch (err) {
    console.error("Search failed:", err);
  } finally {
    spinner.classList.add("hidden");
  }
}

// ── Results Panel (FTS left panel) ────────────────────────────────────

function showFtsResults(results) {
  const list = document.getElementById("results-list");
  const countEl = document.getElementById("results-count");
  const placeholder = document.getElementById("results-placeholder");

  if (results.length === 0) {
    countEl.textContent = "0 results";
    if (placeholder) placeholder.style.display = "";
    list.querySelectorAll(".result-card").forEach((c) => c.remove());
    return;
  }

  if (placeholder) placeholder.style.display = "none";
  countEl.textContent = `${results.length} results`;

  // Clear existing cards
  list.querySelectorAll(".result-card").forEach((c) => c.remove());

  for (const r of results) {
    const card = document.createElement("div");
    card.className = "result-card";
    card.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <span class="text-xs text-indigo-400 font-medium">Chunk #${r.id}</span>
      </div>
      <p class="text-sm text-gray-300">${escapeHtml(r.text)}</p>
    `;
    list.appendChild(card);
  }
}

function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}

// ── Embedding Results Panel (center bottom) ────────────────────────

function showEmbeddingResults(searchResults, chunkMap) {
  const container = document.getElementById("embedding-results");
  if (!container) return;

  container.innerHTML = "";

  if (searchResults.length === 0) {
    container.classList.add("hidden");
    return;
  }

  container.classList.remove("hidden");

  for (const sr of searchResults) {
    const similarity = 1 - sr.distance;
    const text = chunkMap[sr.rowid] || "";
    const card = document.createElement("div");
    card.className = "result-card";
    card.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <span class="text-xs text-indigo-400 font-medium">Chunk #${sr.rowid}</span>
        <span class="text-xs font-mono ${similarity > 0.5 ? "text-amber-400" : similarity > 0.2 ? "text-purple-400" : "text-gray-500"}">${(similarity * 100).toFixed(1)}%</span>
      </div>
      <p class="text-xs text-gray-400">${escapeHtml(text)}</p>
    `;
    container.appendChild(card);
  }
}

// ── Initialization ────────────────────────────────────────────────────

async function initialize() {
  console.log("Initializing muninn WASM demo...");

  try {
    // Phase 1: WASM + SQLite (critical path)
    await initWasm();
    discoverSchema();

    // Phase 2: Visualization (non-blocking for WebGL issues)
    initDeckGL();
    initCytoscape();
    initGraphControls();

    // Phase 3: ML model (slow — first load downloads ~90MB fp32 model)
    await initTransformers();

    // Enable search
    const input = document.getElementById("search-input");
    input.disabled = false;
    const hint = document.getElementById("search-hint");
    hint.textContent =
      "Type a query to search the Wealth of Nations knowledge graph.";

    input.addEventListener("input", (e) => {
      clearTimeout(searchDebounce);
      searchDebounce = setTimeout(() => {
        performSearch(e.target.value);
      }, 300);
    });

    console.log("muninn WASM demo ready");
  } catch (err) {
    console.error("Initialization failed:", err);
    const hint = document.getElementById("search-hint");
    hint.textContent = `Initialization failed: ${err.message}`;
    hint.classList.add("text-red-400");
  }
}

document.addEventListener("DOMContentLoaded", initialize);
